#! /usr/bin/env python
from __future__ import print_function, division

from argparse import ArgumentParser
import logging
import time as tm

from astropy.coordinates import SkyCoord
from astropy.io import fits
import astropy.units as units
from astropy.wcs import WCS
from casacore.tables import table, taql, addImagingColumns
from numba import njit, complex64, complex128, float64, prange
import numpy as np
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter
from scipy.optimize import least_squares

from ddcal.coordinates import radec_to_lm, lm_to_radec
import ddcal.skymodel as skymodel
from ddcal.phaserotate import phase_rotate
import ddcal.phaserotate as phaserotate
import ddcal.predict as predict
import ddcal.residuals as residuals


def main():
    parser = ArgumentParser()
    parser.add_argument('--ms', required=True, help="The measurement set to calibrate")
    parser.add_argument('--model', required=True, help="The sky model (skymodel fileformat 1.1)")
    parser.add_argument('--output', default='tec.fits', help="The output FITS file contains the phase corrections")
    parser.add_argument('--center', required=True, help="Coordinate center of the output FITS file (hh:mm:ss dd:mm:ss)")
    parser.add_argument('--radius', type=float, required=True, help="Radius of output FITS file (degrees)")
    parser.add_argument('--scale', type=float, default=0.25, help="Pixel size of output FITS file (degrees)")
    parser.add_argument('--intervals', default=1, type=int, help="The number of calibration intervals")
    parser.add_argument('--refant', default=0, type=int)
    args = parser.parse_args()

    logging.basicConfig(level='DEBUG')

    center = SkyCoord(args.center, unit=(units.hourangle, units.degree))

    with open(args.model) as f:
        sources = skymodel.parse(f)

    # To simplify things, we fit components separately.
    # This will break for complex, multicomponent sources
    components = [c for source in sources for c in source.components]
    logging.info("%d sources loaded", len(components))

    # Todo: process model into apparent fluxes

    # Open and process measurement set
    mset = table(args.ms, readonly=False, ack=False)
    antids = np.array(range(0, len(mset.ANTENNA)))
    ra0, dec0 = mset.FIELD.getcell('PHASE_DIR', 0)[0]
    freqs = mset.SPECTRAL_WINDOW.getcell('CHAN_FREQ', 0)
    lambdas = 299792458 / freqs
    midfreq = np.array([(max(freqs) + min(freqs)) / 2])
    midlambda = 299792458 / midfreq

    # Calculate antenna positions wrt antenna 0
    times = sorted(set(mset.getcol('TIME')))
    midtime = times[len(times) // 2]
    refant = args.refant
    tmp = taql("select UVW, ANTENNA2 from $mset where TIME = $midtime and ANTENNA1 = $refant")
    (_U, _V, _), antennas = tmp.getcol('UVW').T, tmp.getcol('ANTENNA2')

    # Force U, V indices to align with antenna IDs
    U = np.zeros_like(antids, dtype=np.float64)
    U[antennas] = _U
    V = np.zeros_like(antids, dtype=np.float64)
    V[antennas] = _V

    # Get non-flagged rows
    mset = taql("select * from $mset where not FLAG_ROW")
    flags = mset.getcol('FLAG')
    ant1 = mset.getcol('ANTENNA1')
    ant2 = mset.getcol('ANTENNA2')
    uvw = mset.getcol('UVW')
    data = np.complex128(mset.getcol('DATA'))
    data[flags] = np.nan

    metadata = phaserotate.Metadata(mset)
    uvw, data = phase_rotate(uvw, data, ra0, dec0, metadata)  # Reset phase direction
    u, v, w = uvw.T[:, :, None] / lambdas

    # Perform directional calibration
    # First pass
    logging.info("Beginning pass 1")
    solutions = []
    for comp in components:
        # Phase rotate onto source and average in frequency
        _, rotated = phase_rotate(uvw, data[:, :, [True, False, False, True]], comp.ra, comp.dec, metadata)
        start = tm.time()
        rotated = freq_average(rotated)[:, None, :]
        elapsed = tm.time() - start
        logging.debug("Frequency averaging elapsed: %g", elapsed)

        # Create model
        model = np.ones_like(rotated)

        # Fit
        start = tm.time()
        res = least_squares(
            residuals.full_firstorder,
            (comp.apparent(midfreq), comp.apparent(midfreq), 0, 0),
            args=(U, V, ant1, ant2, rotated, model),
            verbose=2,
            x_scale=[1e-2, 1e-2, 1e-5, 1e-5],
        )
        logging.debug("First order fit elapsed: %g", tm.time() - start)
        logging.debug(res.message)
        solutions.append(res.x)
        Ax, Ay, x, y = res.x
        logging.debug("Model flux: %g versus fit flux (Ax Ay): %g %g", comp.apparent(midfreq), Ax, Ay)
        logging.debug("Fit params: %g %g %g %g", *res.x)

        # Peel
        start = tm.time()
        phases = x * U + y * V
        phases = phases[ant1] - phases[ant2]
        l, m = radec_to_lm(comp.ra, comp.dec, ra0, dec0)
        peel(data, u, v, w, l, m, Ax, Ay, phases)
        logging.debug("Peeled first order elapsed: %g", tm.time() - start)

    # Second pass
    logging.info("Beginning pass 2")
    for i, (comp, (Ax, Ay, x, y)) in enumerate(zip(components, solutions)):
        # Unpeel
        start = tm.time()
        phases = x * U + y * V
        phases = phases[ant1] - phases[ant2]
        l, m = radec_to_lm(comp.ra, comp.dec, ra0, dec0)
        unpeel(data, u, v, w, l, m, Ax, Ay, phases)
        logging.debug("Unpeeled elapsed: %g", tm.time() - start)

        # Phase rotate onto source and average in frequency
        _, rotated = phase_rotate(uvw, data[:, :, [True, False, False, True]], comp.ra, comp.dec, metadata)
        start = tm.time()
        rotated = freq_average(rotated)[:, None, :]
        elapsed = tm.time() - start
        logging.debug("Frequency averaging elapsed: %g", elapsed)

        model = np.ones_like(rotated)

        start = tm.time()
        res = least_squares(
            residuals.full_secondorder,
            (Ax, Ay, x, y, 0, 0, 0),
            args=(U, V, ant1, ant2, rotated, model),
            verbose=2,
            x_scale=[1e-2, 1e-2, 1e-5, 1e-5, 1e-9, 1e-9, 1e-9],
        )
        logging.debug("Second order fit elapsed: %g", tm.time() - start)
        logging.debug(res.message)
        solutions[i] = res.x
        Ax, Ay, x, y, xx, xy, yy = res.x
        logging.debug("Model flux: %g versus fit flux (Ax Ay): %g %g", comp.apparent(midfreq), Ax, Ay)
        logging.debug("Fit params: %g %g %g %g %g %g %g", *res.x)
        logging.debug(res.message)

        # Peel
        start = tm.time()
        phases = x * U + y * V + xx * U**2 + xy * U * V + yy * V**2
        phases = phases[ant1] - phases[ant2]
        l, m = radec_to_lm(comp.ra, comp.dec, ra0, dec0)
        peel(data, u, v, w, l, m, Ax, Ay, phases)
        logging.debug("Peeled second order elapsed: %g", tm.time() - start)

    # Create lists of lm coordinates in the FITS projection for calibration directions
    ras = np.array([comp.ra for comp in components])
    decs = np.array([comp.dec for comp in components])
    directions_lm = radec_to_lm(ras, decs, center.ra.rad, center.dec.rad)

    # Solve phases for each antenna for each calibration direction
    _, _, x, y, xx, xy, yy = np.array(solutions).T
    phases = (
        x[None, :] * U[:, None] +
        y[None, :] * V[:, None] +
        xx[None, :] * U[:, None]**2 +
        xy[None, :] * U[:, None] * V[:, None] +
        yy[None, :] * V[:, None]**2
    )  # [antennas, directions]

    gaintable = table('ddcal.gcal', readonly=False)
    gains = gaintable.getcol('CPARAM')
    gains[:, :, :] = np.exp(-1j * phases[:, 0])[:, None, None]
    gaintable.putcol('CPARAM', gains)
    flags = gaintable.getcol('FLAG')
    flags[:, :] = False
    gaintable.putcol('FLAG', flags)

    # Provision TEC fits file and set up headers
    width, height = int((2 * args.radius) // args.scale), int((2 * args.radius) // args.scale)
    center_x, center_y = int(width // 2), int(height // 2)

    logging.info("Creating TEC image of dimensions (%d, %d)", width, height)

    data = np.zeros((1, 1, len(antids), height, width), dtype=np.float)  # [time, frequency, antennas, dec, ra]
    Atec = fits.PrimaryHDU(data)

    Atec.header['CTYPE1'] = 'RA---SIN'
    Atec.header['CRPIX1'] = center_x
    Atec.header['CRVAL1'] = center.ra.deg
    Atec.header['CDELT1'] = args.scale
    Atec.header['CUNIT1'] = 'deg'

    Atec.header['CTYPE2'] = 'DEC--SIN'
    Atec.header['CRPIX2'] = center_y
    Atec.header['CRVAl2'] = center.dec.deg
    Atec.header['CDELT2'] = args.scale
    Atec.header['CUNIT2'] = 'deg'

    Atec.header['CTYPE3'] = 'ANTENNA'
    Atec.header['CRPIX3'] = 1
    Atec.header['CRVAL3'] = 0

    Atec.header['CTYPE4'] = 'FREQ'
    Atec.header['CRPIX4'] = 1
    Atec.header['CRVAL4'] = midfreq[0]
    Atec.header['CDELT4'] = 1
    Atec.header['CUNIT4'] = 'Hz'

    Atec.header['CTYPE5'] = 'TIME'
    Atec.header['CRPIX5'] = 1
    Atec.header['CRVAL5'] = midtime  # FIXME
    Atec.header['CDELT5'] = 1

    wcs = WCS(Atec.header)

    # Get oversampled l,m values for TEC file
    xx, yy = np.meshgrid(range(0, 3 * width), range(0, 3 * height))
    pixels = np.array([xx.flatten(), yy.flatten()]).T

    ret = wcs.all_pix2world([[x / 3 - 1/3, y / 3 - 1/3, 0, 0, 0] for x, y in pixels], 0)
    grid_lm = radec_to_lm(np.radians(ret.T[0]), np.radians(ret.T[1]), center.ra.rad, center.dec.rad)

    for i in antids:
        # Compute interpolated phases
        phases_grid = griddata(directions_lm.T, phases[i], grid_lm.T, method='nearest')
        phases_grid = np.reshape(phases_grid, (3*height, 3*width))  # [ dec, ra ]

        # Gaussian smooth
        phases_grid = gaussian_filter(phases_grid, 3, mode='constant', cval=0)

        # Downsample
        phases_grid = phases_grid[1::3, 1::3]

        data[0, 0, i] = phases_grid / 8.44797245E9 * midfreq

    Atec.writeto(args.output, overwrite=True)


@njit([(complex128[:, :, :], float64[:, :], float64[:, :], float64[:, :], float64, float64, float64, float64, float64[:])], parallel=True)
def peel(data, u, v, w, l, m, Ax, Ay, phases):
    n = np.sqrt(1 - l**2 - m**2) - 1

    for row in prange(0, u.shape[0]):
        phase = 2j * np.pi * (u[row]*l + v[row]*m + w[row]*n)
        phase = np.exp(phase - 1j * phases[row])

        data[row, :, 0] -= Ax * phase
        data[row, :, 3] -= Ay * phase


@njit([(complex128[:, :, :], float64[:, :], float64[:, :], float64[:, :], float64, float64, float64, float64, float64[:])], parallel=True)
def unpeel(data, u, v, w, l, m, Ax, Ay, phases):
    n = np.sqrt(1 - l**2 - m**2) - 1

    for row in prange(0, u.shape[0]):
        phase = 2j * np.pi * (u[row]*l + v[row]*m + w[row]*n)
        phase = np.exp(phase - 1j * phases[row])

        data[row, :, 0] += Ax * phase
        data[row, :, 3] += Ay * phase


@njit([complex128[:, :](complex128[:, :, :])], parallel=True)
def freq_average(data):
    averaged = np.empty_like(data[:, 0, :])
    for row in prange(0, data.shape[0]):
        for pol in prange(0, data.shape[2]):
            averaged[row, pol] = np.nanmean(data[row, :, pol])

    return averaged

if __name__ == '__main__':
    main()

