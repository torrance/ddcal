#! /usr/bin/env python
from __future__ import print_function, division

from argparse import ArgumentParser
import csv
import logging
import os.path
import sys
import time as tm

from astropy.coordinates import SkyCoord
from astropy.io import fits
import astropy.units as units
from astropy.wcs import WCS
from casacore.tables import table, maketabdesc, makearrcoldesc
import numpy as np
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter

import radical.calibrate as calibrate
import radical.constants as constants
from radical.coordinates import radec_to_lm, lm_to_radec
from radical.measurementset import MeasurementSet
from radical.mwabeam import MWABeam
import radical.skymodel as skymodel
from radical.peel import peel, unpeel
from radical.phaserotate import phase_rotate
from radical.solution import Solution


def main():
    parser = ArgumentParser("radical", description="radical: Radio Astronomy Directional Ionospheric CALibration")
    parser.add_argument('--ms', required=True, help="The measurement set to calibrate")
    parser.add_argument('--model', required=True, help="The sky model (skymodel fileformat 1.1)")
    parser.add_argument('--output', default='tec.fits', help="The output FITS file contains the phase corrections")
    parser.add_argument('--center', required=True, help="Coordinate center of the output FITS file (hh:mm:ss dd:mm:ss)")
    parser.add_argument('--radius', type=float, required=True, help="Radius of output FITS file (degrees)")
    parser.add_argument('--scale', type=float, default=0.25, help="Pixel size of output FITS file (degrees)")
    parser.add_argument('--intervals', default=1, type=int, help="The number of calibration intervals")
    parser.add_argument('--refant', default=0, type=int)
    parser.add_argument('--oversample', default=3, type=int)
    parser.add_argument('--smoothing-kernel', default=1, type=float, help="The gaussian smoothing kernal width (sigma) in units of --scale")
    parser.add_argument('--flux-threshold', default=1, type=float, help="Sources with apparent flux values (Jy) under this threshold will not be fit with 2nd order terms")
    parser.add_argument('--metafits', required=True, help="Path to the metafits file")
    parser.add_argument('--nsources', type=int, default=0, help="Limit calibration just to brightest (apparent) nsources")
    parser.add_argument('--orders', type=int, nargs='+', default=[1, 2], help="The order of solution to solve for on each pass. \
                                                                              This parameter allows to tweak the number _and_ type of each pass, \
                                                                              eg. --orders 2 will complete only one pass, \
                                                                              solving for a second order solution directly. \
                                                                              Default: 1, 2")
    parser.add_argument('--debug', action='store_true')
    args = parser.parse_args()

    logger = logging.getLogger(__name__)
    if args.debug:
        logger.setLevel('DEBUG')
    else:
        logger.setLevel('INFO')

    mset = MeasurementSet(args.ms, refant=args.refant)
    center = SkyCoord(args.center, unit=(units.hourangle, units.degree))

    # Parse skymodel and load sources
    with open(args.model) as f:
        sources = skymodel.parse(f)

    logger.info("Calculating apparent flux of model sources...")
    # Set beam for each component so that we can later calculate apparent flux
    beam = MWABeam(args.metafits)
    for src in sources:
        for comp in src.components:
            comp.beam = beam

    # Calculate apparent flux and reorder components from brightest to dimmest
    sources = sorted(sources, reverse=True, key=lambda x: x.apparent(mset.midfreq))
    logger.info("Model sources ordered by apparent flux")

    # Limit number of sources to calibrate to nsources
    if args.nsources:
        sources = sources[0:args.nsources]

    # Create empty solutions and populate Ax, Ay
    solutions = []
    for src in sources:
        solution = Solution(ncomp=len(src.components))
        solution.set_params([A for comp in src.components for A in comp.apparent(mset.midfreq)])
        solutions.append(solution)

    # Begin directional calibration
    for npass, order in enumerate(args.orders):
        logger.info("Beginning pass %d", npass+1)

        for src, solution in zip(sources, solutions):
            # Don't try higher order fits if we've previously failed to fit
            if solution.failed:
                continue

            # For second and higher order fits, we need to unpeel previously peeled sources
            if npass > 0:
                # Unpeel
                start = tm.time()
                phases = solution.phasecorrections(mset)
                for (Ax, Ay), comp in zip(solution.amplitudes, src.components):
                    l, m = radec_to_lm(comp.ra, comp.dec, mset.ra0, mset.dec0)
                    unpeel(mset.data, mset.u_lambda, mset.v_lambda, mset.w_lambda, l, m, Ax, Ay, phases)
                logger.debug("Unpeeled elapsed: %g", tm.time() - start)

            # Update solution with best fit
            calibrate.solve(src, solution, mset, order)

            # Peel the source
            start = tm.time()
            phases = solution.phasecorrections(mset)
            for (Ax, Ay), comp in zip(solution.amplitudes, src.components):
                l, m = radec_to_lm(comp.ra, comp.dec, mset.ra0, mset.dec0)
                peel(mset.data, mset.u_lambda, mset.v_lambda, mset.w_lambda, l, m, Ax, Ay, phases)
            logger.debug("Peeled elapsed: %g", tm.time() - start)

    # Create ms of peeling sources for debugging purposes
    if args.debug:
        if 'PEELED' not in mset.colnames():
            col_dmi = mset.getdminfo('DATA')
            col_dmi['NAME'] = 'PEELED'
            shape = mset.getcell('DATA', 0).shape
            mset.addcols(maketabdesc(makearrcoldesc('PEELED', 0.0+0.0j, valuetype='complex', shape=shape)), col_dmi)
        mset.filtered.putcol('PEELED', mset.data)
        mset.close()

        # Print model to ds9 format
        with open(os.path.splitext(args.out)[0] + '.reg', 'w') as f:
            print("global color=red dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1", file=f)
            for src, sol in zip(sources, solutions):
                if not sol.failed:
                    for comp in src.components:
                        print("point %fd %fd # point=circle text={%s}" % (comp.position.ra.deg, comp.position.dec.deg, src.name), file=f)

    # Print out solutions
    with open(os.path.splitext(args.out)[0] + '.csv', 'w') as f:
        writer = csv.writer(f)
        writer.writerow(['sourcename', 'ra', 'dec', 'status', 'x', 'y', 'xx', 'xy', 'yy', 'A1x', 'A1y', 'A2x', 'A2y'])
        for src, solution in zip(sources, solutions):
            writer.writerow([src.name, np.degrees(src.ra), np.degrees(src.dec), not solution.failed] + solution.get_params(2)[-5:] + solution.get_params(0))

    # Create lists of lm coordinates in the FITS projection for calibration directions
    ras = np.array([src.ra for i, src in enumerate(sources) if not solutions[i].failed])
    decs = np.array([src.dec for i, src in enumerate(sources) if not solutions[i].failed])
    directions_lm = radec_to_lm(ras, decs, center.ra.rad, center.dec.rad)

    # Solve phases for each antenna for each calibration direction
    phases = np.empty((len(mset.antids), len(directions_lm.T)))
    for i, solution in enumerate(solutions):
        if not solution.failed:
            phases[:, i] = solution.phases(mset.U, mset.V)

    gaintable = table('ddcal.gcal', readonly=False)
    gains = gaintable.getcol('CPARAM')
    gains[:, :, :] = np.exp(-1j * phases[:, 0])[:, None, None]
    gaintable.putcol('CPARAM', gains)
    flags = gaintable.getcol('FLAG')
    flags[:, :] = False
    gaintable.putcol('FLAG', flags)
    exit()

    np.save('directions_lm.npy', directions_lm)
    np.save('phases.npy', phases)
    directions_lm = np.load('directions_lm.npy')
    phases = np.load('phases.npy')

    # Provision TEC fits file and set up headers
    width, height = int((2 * args.radius) // args.scale), int((2 * args.radius) // args.scale)
    center_x, center_y = int(width // 2), int(height // 2)

    logger.info("Creating TEC image of dimensions (%d, %d)", width, height)

    data = np.zeros((1, 1, len(mset.antids), height, width), dtype=np.float)  # [time, frequency, antennas, dec, ra]
    Atec = fits.PrimaryHDU(data)

    Atec.header['CTYPE1'] = 'RA---SIN'
    Atec.header['CRPIX1'] = center_x
    Atec.header['CRVAL1'] = center.ra.deg
    Atec.header['CDELT1'] = args.scale
    Atec.header['CUNIT1'] = 'deg'

    Atec.header['CTYPE2'] = 'DEC--SIN'
    Atec.header['CRPIX2'] = center_y
    Atec.header['CRVAl2'] = center.dec.deg
    Atec.header['CDELT2'] = args.scale
    Atec.header['CUNIT2'] = 'deg'

    Atec.header['CTYPE3'] = 'ANTENNA'
    Atec.header['CRPIX3'] = 1
    Atec.header['CRVAL3'] = 0

    Atec.header['CTYPE4'] = 'FREQ'
    Atec.header['CRPIX4'] = 1
    Atec.header['CRVAL4'] = mset.midfreq[0]
    Atec.header['CDELT4'] = 1
    Atec.header['CUNIT4'] = 'Hz'

    Atec.header['CTYPE5'] = 'TIME'
    Atec.header['CRPIX5'] = 1
    Atec.header['CRVAL5'] = mset.midtime  # FIXME
    Atec.header['CDELT5'] = 1

    Atec.header['HISTORY'] = 'radical ' + ' '.join(sys.argv[1:])
    print(' '.join(sys.argv))

    wcs = WCS(Atec.header)

    # Get oversampled l,m values for TEC file
    xx, yy = np.meshgrid(range(0, args.oversample * width), range(0, args.oversample * height))
    pixels = np.array([xx.flatten(), yy.flatten()]).T

    ret = wcs.all_pix2world([[x / args.oversample - 1/args.oversample, y / args.oversample - 1/args.oversample, 0, 0, 0] for x, y in pixels], 0)
    grid_lm = radec_to_lm(np.radians(ret.T[0]), np.radians(ret.T[1]), center.ra.rad, center.dec.rad)

    for i in mset.antids:
        # Compute interpolated phases
        phases_grid = griddata(directions_lm.T, phases[i], grid_lm.T, method='nearest')
        phases_grid = np.reshape(phases_grid, (args.oversample * height, args.oversample * width))  # [ dec, ra ]

        # Gaussian smooth
        phases_grid = gaussian_filter(phases_grid, args.oversample * args.smoothing_kernel, mode='constant', cval=0)

        # Downsample
        phases_grid = phases_grid[1::args.oversample, 1::args.oversample]

        data[0, 0, i] = phases_grid / 8.44797245E9 * mset.midfreq

    Atec.writeto(args.output, overwrite=True)


def interpolate(xs, ys, zs, points, power=1):
    dists = np.sqrt((points[:, 0, None] - xs[None, :])**2 + (points[:, 1, None] - ys[None, :])**2)  # [point, xyz]

    weights = 1 / dists**power
    weights = weights / weights.sum(axis=1)[:, None]  # Normalisation

    vals = (weights * zs[None, :]).sum(axis=1)
    return vals


if __name__ == '__main__':
    main()

